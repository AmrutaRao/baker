{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (data) Events More about these concepts here . Overview Baker allows you to: Declaritavely design your processes using a recipe DSL . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your process instances. Visual representation Below an example of a simple web shop recipe:","title":"Home"},{"location":"#introduction","text":"Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (data) Events More about these concepts here .","title":"Introduction"},{"location":"#overview","text":"Baker allows you to: Declaritavely design your processes using a recipe DSL . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your process instances.","title":"Overview"},{"location":"#visual-representation","text":"Below an example of a simple web shop recipe:","title":"Visual representation"},{"location":"getting-started/","text":"Getting started Project setup Baker is released to maven central . You can add following dependencies to your maven or sbt project to start using it: Sbt dependencies += com.ing.baker %% baker-recipe-dsl % 2.0.1 dependencies += com.ing.baker %% baker-compiler % 2.0.1 dependencies += com.ing.baker %% baker-runtime % 2.0.1 Maven dependencies groupId com.ing.baker /groupId artifactId baker-recipe-dsl_2.12 /artifactId version 2.0.1 /version /dependencies dependencies groupId com.ing.baker /groupId artifactId baker-compiler_2.12 /artifactId version 2.0.1 /version /dependencies dependencies groupId com.ing.baker /groupId artifactId baker-runtime_2.12 /artifactId version 2.0.1 /version /dependencies This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need. Modules An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri Net model that the runtime can execute This is the dependency graph between the modules. Continuing from here After adding the dependencies you can continue to: Familiarize yourself with the concepts . Immediately start writing your recipes .","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#project-setup","text":"Baker is released to maven central . You can add following dependencies to your maven or sbt project to start using it: Sbt dependencies += com.ing.baker %% baker-recipe-dsl % 2.0.1 dependencies += com.ing.baker %% baker-compiler % 2.0.1 dependencies += com.ing.baker %% baker-runtime % 2.0.1 Maven dependencies groupId com.ing.baker /groupId artifactId baker-recipe-dsl_2.12 /artifactId version 2.0.1 /version /dependencies dependencies groupId com.ing.baker /groupId artifactId baker-compiler_2.12 /artifactId version 2.0.1 /version /dependencies dependencies groupId com.ing.baker /groupId artifactId baker-runtime_2.12 /artifactId version 2.0.1 /version /dependencies This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need.","title":"Project setup"},{"location":"getting-started/#modules","text":"An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri Net model that the runtime can execute This is the dependency graph between the modules.","title":"Modules"},{"location":"getting-started/#continuing-from-here","text":"After adding the dependencies you can continue to: Familiarize yourself with the concepts . Immediately start writing your recipes .","title":"Continuing from here"},{"location":"migration-guide/","text":"Migration Guide From 1.3.x to 2.0.0 This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog . Downtime required for clusters with state In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended. Removed Ingredient interface com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable . @ProvidesIngredient removed In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( email ) String apply ( @RequiresIngredient ( customer ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( customer ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"Migration Guide"},{"location":"migration-guide/#migration-guide","text":"","title":"Migration Guide"},{"location":"migration-guide/#from-13x-to-200","text":"This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog .","title":"From 1.3.x to 2.0.0"},{"location":"migration-guide/#downtime-required-for-clusters-with-state","text":"In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended.","title":"Downtime required for clusters with state"},{"location":"migration-guide/#removed-ingredient-interface","text":"com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable .","title":"Removed Ingredient interface"},{"location":"migration-guide/#providesingredient-removed","text":"In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( email ) String apply ( @RequiresIngredient ( customer ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( customer ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"@ProvidesIngredient removed"},{"location":"documentation/baker-runtime/","text":"Baker Runtime With the Recipe DSL you can create a description of your recipe. This does not yet constitute a runnable process. It is just a description. To execute manage your recipes you require the Baker Runtime . Starting the baker runtime Creating a baker runtime is as easy as calling the empty constructor. Scala // Create a Baker Runtime val baker = new Baker (); Java // Create a Baker Runtime JBaker baker = new JBaker (); Baker is build on top op akka . It requires an ActorSystem to start. In the previous example the actor system is not provided. In that case baker will create an actor system for you. If you already have an actor system then you can give it to Baker. Scala val actorSystem = ActorSystem (); Baker baker = new Baker ( actorSystem ); Java ActorSystem actorSystem = ActorSystem . create (); JBaker baker = new JBaker ( actorSystem ); Adding interaction implementations Before you can add a recipe all the interactions for that recipe MUST have an implemention in Baker. You can add them like this: Scala val validateOrderImpl = new ValidateOrderImpl () baker . addImplementation ( validateOrderImpl ) Java ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); baker . addImplementation ( validateOrderImpl ); Compiling your Recipe A recipe is writen in a DSL . This is just a declarative description of your process. In order to execute it we need to compile it. This connects all the pieces into a graph (more precisly a petri net ). For this purpose there is the RecipeCompiler . Scala val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); Did you know?! You can use a compiled recipe to create a visual representation. See the visualization page how to create a visual graph. Adding your Compiled Recipe Once you have compiled your recipe you can add it to Baker. Scala baker . addRecipe ( compiledRecipe ) Java baker . addRecipe ( compiledRecipe ); Putting it all together Combining all these steps gives us the following: // Implementations, probably defined in other files ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); ManufactureGoodsImpl manufactureGoodsImpl = new ManufactureGoodsImpl (); // Compiling the Recipe CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); // Creating a Baker Runtime JBaker baker = new JBaker (); // Add the Implementations baker . addImplementations ( validateOrderImpl , manufactureGoodsImpl ); // Add the Compiled Recipe String recipeId = baker . addRecipe ( compiledRecipe ); Baker is now ready to create an instance for the recipe and execute it.","title":"Baker Runtime"},{"location":"documentation/baker-runtime/#baker-runtime","text":"With the Recipe DSL you can create a description of your recipe. This does not yet constitute a runnable process. It is just a description. To execute manage your recipes you require the Baker Runtime .","title":"Baker Runtime"},{"location":"documentation/baker-runtime/#starting-the-baker-runtime","text":"Creating a baker runtime is as easy as calling the empty constructor. Scala // Create a Baker Runtime val baker = new Baker (); Java // Create a Baker Runtime JBaker baker = new JBaker (); Baker is build on top op akka . It requires an ActorSystem to start. In the previous example the actor system is not provided. In that case baker will create an actor system for you. If you already have an actor system then you can give it to Baker. Scala val actorSystem = ActorSystem (); Baker baker = new Baker ( actorSystem ); Java ActorSystem actorSystem = ActorSystem . create (); JBaker baker = new JBaker ( actorSystem );","title":"Starting the baker runtime"},{"location":"documentation/baker-runtime/#adding-interaction-implementations","text":"Before you can add a recipe all the interactions for that recipe MUST have an implemention in Baker. You can add them like this: Scala val validateOrderImpl = new ValidateOrderImpl () baker . addImplementation ( validateOrderImpl ) Java ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); baker . addImplementation ( validateOrderImpl );","title":"Adding interaction implementations"},{"location":"documentation/baker-runtime/#compiling-your-recipe","text":"A recipe is writen in a DSL . This is just a declarative description of your process. In order to execute it we need to compile it. This connects all the pieces into a graph (more precisly a petri net ). For this purpose there is the RecipeCompiler . Scala val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); Did you know?! You can use a compiled recipe to create a visual representation. See the visualization page how to create a visual graph.","title":"Compiling your Recipe"},{"location":"documentation/baker-runtime/#adding-your-compiled-recipe","text":"Once you have compiled your recipe you can add it to Baker. Scala baker . addRecipe ( compiledRecipe ) Java baker . addRecipe ( compiledRecipe );","title":"Adding your Compiled Recipe"},{"location":"documentation/baker-runtime/#putting-it-all-together","text":"Combining all these steps gives us the following: // Implementations, probably defined in other files ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); ManufactureGoodsImpl manufactureGoodsImpl = new ManufactureGoodsImpl (); // Compiling the Recipe CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); // Creating a Baker Runtime JBaker baker = new JBaker (); // Add the Implementations baker . addImplementations ( validateOrderImpl , manufactureGoodsImpl ); // Add the Compiled Recipe String recipeId = baker . addRecipe ( compiledRecipe ); Baker is now ready to create an instance for the recipe and execute it.","title":"Putting it all together"},{"location":"documentation/concepts/","text":"Concepts Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints) Ingredient Ingredients are pure data . This data is immutable , can not be changed after entering the process. There is no hi\u00ebrarchy in this data. ( Animal - Dog - Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the baker type system . Interaction An interaction is analagous to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output. Interaction failure An interaction may fail to fulfill its intended purpose. We distinquish 2 types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of unreliable network, packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction. Failure mitigation In case of technical failures, baker offers 2 mitigation strategies: Retry with incremental backoff This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The backoff factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in java code. The exception is logged but the process continues with a specified event. When no failure strategy is defined for an interaction by default the interaction is blocked . Event An event has a name and can (optionally) provide ingredients. The purpose of events is therefor twofold. It signifies something of interest happened for a process instance . Example, \"the customer placed the order\" , \"terms and conditions where accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" - list of products We distinquish 2 types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed. Recipe Events , Interactions and Ingredients can be composed into recipes. Recipes are analagous to process blueprints. Baker provides a Recipe DSL in which you can declaritively describe your recipe. A small example: new Recipe ( webshop ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions.","title":"Concepts"},{"location":"documentation/concepts/#concepts","text":"Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints)","title":"Concepts"},{"location":"documentation/concepts/#ingredient","text":"Ingredients are pure data . This data is immutable , can not be changed after entering the process. There is no hi\u00ebrarchy in this data. ( Animal - Dog - Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the baker type system .","title":"Ingredient"},{"location":"documentation/concepts/#interaction","text":"An interaction is analagous to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output.","title":"Interaction"},{"location":"documentation/concepts/#interaction-failure","text":"An interaction may fail to fulfill its intended purpose. We distinquish 2 types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of unreliable network, packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction.","title":"Interaction failure"},{"location":"documentation/concepts/#failure-mitigation","text":"In case of technical failures, baker offers 2 mitigation strategies: Retry with incremental backoff This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The backoff factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in java code. The exception is logged but the process continues with a specified event. When no failure strategy is defined for an interaction by default the interaction is blocked .","title":"Failure mitigation"},{"location":"documentation/concepts/#event","text":"An event has a name and can (optionally) provide ingredients. The purpose of events is therefor twofold. It signifies something of interest happened for a process instance . Example, \"the customer placed the order\" , \"terms and conditions where accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" - list of products We distinquish 2 types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed.","title":"Event"},{"location":"documentation/concepts/#recipe","text":"Events , Interactions and Ingredients can be composed into recipes. Recipes are analagous to process blueprints. Baker provides a Recipe DSL in which you can declaritively describe your recipe. A small example: new Recipe ( webshop ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions.","title":"Recipe"},{"location":"documentation/dictionary/","text":"Dictionary Here we define some common used lanuage that is used in this documentation. Name Description Recipe A process blue print Recipe id A unique identifier for a Recipe which is computed (a hash). Process instance A running instance of a Recipe Process id A unique identifier for a process instance which is chosen by the user. Sensory event An event given to baker for a process instance","title":"Dictionary"},{"location":"documentation/dictionary/#dictionary","text":"Here we define some common used lanuage that is used in this documentation. Name Description Recipe A process blue print Recipe id A unique identifier for a Recipe which is computed (a hash). Process instance A running instance of a Recipe Process id A unique identifier for a process instance which is chosen by the user. Sensory event An event given to baker for a process instance","title":"Dictionary"},{"location":"documentation/event-listener/","text":"Event Listener Often it may be of interest to be notified of events that occur while operating Baker. There are 2 types of events that can be subscribed to. Events defined in your recipe that occur in the context of a process instance. Technical / internal events that occur within the baker runtime. Important limitations Event delivery is asynchronous , NO order guarantee is given All events do come with time stamps. Event delivery is AT MOST ONCE In case of ungraceful shutdown, you may miss events. Because of these limitations it is not recommended to use these listeners for primary business logic. Process instance events You might be interested which Events are raised for process instances of a recipe. For this purpose there is an EventListener interface. You may implement this interface and register it to Baker. Scala val listener : EventListener = new EventListener { override def processEvent ( processId : String , event : RuntimeEvent ) = ??? } val baker : Baker = ??? // initialize baker baker . registerEventListener ( listener ); Java EventListener listener = new EventListener () { @Override public void processEvent ( String processId , RuntimeEvent event ) { // } } JBaker baker = null ; // initialize baker baker . registerEventListener ( listener ); Internal events For the purpose of logging, tracing, etc.. is is possible to register to internal events that happen inside Baker. List of events Class Description ProcessCreated A process instance was created EventReceived A sensory event for a process instance was received EventRejected A sensory event for a process instance was rejected InteractionStarted An interaction started executing InteractionCompleted An interaction completed executing InteractionFailed An interaction failed during execution RecipeAdded A Recipe was added Subscription mechanism You can subscribe to these events by registering a listener to baker. In scala partial functions are used. In java you can register objects that have methods annotated with @Subscribe . In case you are interested in ALL events you can register to the general BakerEvent . In the example below a listener is registered that is only interested in EventReceived : Scala import com.ing.baker.runtime.core.events._ val baker : com.ing.baker.runtime.core.Baker = ??? // initialize baker baker . registerListenerPF { case e : EventReceived = // ... } Java import com.ing.baker.runtime.core.events.* ; class Subscriber { @Subscribe public void receiveEventReceived ( EventReceived event ) { // ... } } com . ing . baker . runtime . java_api . JBaker baker = null ; // initialize baker baker . registerEventListener ( new Subscriber ());","title":"Event Listener"},{"location":"documentation/event-listener/#event-listener","text":"Often it may be of interest to be notified of events that occur while operating Baker. There are 2 types of events that can be subscribed to. Events defined in your recipe that occur in the context of a process instance. Technical / internal events that occur within the baker runtime.","title":"Event Listener"},{"location":"documentation/event-listener/#important-limitations","text":"Event delivery is asynchronous , NO order guarantee is given All events do come with time stamps. Event delivery is AT MOST ONCE In case of ungraceful shutdown, you may miss events. Because of these limitations it is not recommended to use these listeners for primary business logic.","title":"Important limitations"},{"location":"documentation/event-listener/#process-instance-events","text":"You might be interested which Events are raised for process instances of a recipe. For this purpose there is an EventListener interface. You may implement this interface and register it to Baker. Scala val listener : EventListener = new EventListener { override def processEvent ( processId : String , event : RuntimeEvent ) = ??? } val baker : Baker = ??? // initialize baker baker . registerEventListener ( listener ); Java EventListener listener = new EventListener () { @Override public void processEvent ( String processId , RuntimeEvent event ) { // } } JBaker baker = null ; // initialize baker baker . registerEventListener ( listener );","title":"Process instance events"},{"location":"documentation/event-listener/#internal-events","text":"For the purpose of logging, tracing, etc.. is is possible to register to internal events that happen inside Baker.","title":"Internal events"},{"location":"documentation/event-listener/#list-of-events","text":"Class Description ProcessCreated A process instance was created EventReceived A sensory event for a process instance was received EventRejected A sensory event for a process instance was rejected InteractionStarted An interaction started executing InteractionCompleted An interaction completed executing InteractionFailed An interaction failed during execution RecipeAdded A Recipe was added","title":"List of events"},{"location":"documentation/event-listener/#subscription-mechanism","text":"You can subscribe to these events by registering a listener to baker. In scala partial functions are used. In java you can register objects that have methods annotated with @Subscribe . In case you are interested in ALL events you can register to the general BakerEvent . In the example below a listener is registered that is only interested in EventReceived : Scala import com.ing.baker.runtime.core.events._ val baker : com.ing.baker.runtime.core.Baker = ??? // initialize baker baker . registerListenerPF { case e : EventReceived = // ... } Java import com.ing.baker.runtime.core.events.* ; class Subscriber { @Subscribe public void receiveEventReceived ( EventReceived event ) { // ... } } com . ing . baker . runtime . java_api . JBaker baker = null ; // initialize baker baker . registerEventListener ( new Subscriber ());","title":"Subscription mechanism"},{"location":"documentation/execution-semantics/","text":"Execution sementics Execution loop This is a short description of the execution loop of a process instance An event is raised and provides ingredients. Either given to baker as a sensory event or by an interaction. A check is done which interactions have all their requirements met and those are executed. An interaction completes its execution and outputs an event ( GOTO 1. ) Notes A sensory event may be provided 1 or more times depending on its firing limit . When ingredients are provided multiple times, the latest value overrides the previous. An interaction fires when all it's ingredients and required events are provided. This may happen 1 or more times depending on the maximum interaction count . To know more you will first need to understand the how a petri net works. Below is an explanation of how a recipe relates to a petri net. In depth A recipe can be represented (and visualized ) as a graph. This graph is actually a higher level representation of a petri net (which is also a graph). The execution of a process instance based around this petri net. The recipe compiler takes a recipe and creates a petri net. Generally the petri net is graph more complicated with extra layers of wiring nodes. Translation rules The compiler has some rules about translating recipe parts to transitions and places in the petri net. Ingredient used by multiple interactions Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by 1 transition we have to add a layer to duplicate the token for all transitions. Interaction with precondition (AND) By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction. Interaction with precodition (OR) Events that are grouped in an OR combinator for an interaction output a token to the same place. Therefor when one of them fires the condition for the transition to fire is met. Sensory event with firing limit When specifying a sensory event with a firing limit of n we generate a in-adjacent place with n tokens in the initial marking.","title":"Execution sementics"},{"location":"documentation/execution-semantics/#execution-sementics","text":"","title":"Execution sementics"},{"location":"documentation/execution-semantics/#execution-loop","text":"This is a short description of the execution loop of a process instance An event is raised and provides ingredients. Either given to baker as a sensory event or by an interaction. A check is done which interactions have all their requirements met and those are executed. An interaction completes its execution and outputs an event ( GOTO 1. )","title":"Execution loop"},{"location":"documentation/execution-semantics/#notes","text":"A sensory event may be provided 1 or more times depending on its firing limit . When ingredients are provided multiple times, the latest value overrides the previous. An interaction fires when all it's ingredients and required events are provided. This may happen 1 or more times depending on the maximum interaction count . To know more you will first need to understand the how a petri net works. Below is an explanation of how a recipe relates to a petri net.","title":"Notes"},{"location":"documentation/execution-semantics/#in-depth","text":"A recipe can be represented (and visualized ) as a graph. This graph is actually a higher level representation of a petri net (which is also a graph). The execution of a process instance based around this petri net. The recipe compiler takes a recipe and creates a petri net. Generally the petri net is graph more complicated with extra layers of wiring nodes.","title":"In depth"},{"location":"documentation/execution-semantics/#translation-rules","text":"The compiler has some rules about translating recipe parts to transitions and places in the petri net.","title":"Translation rules"},{"location":"documentation/execution-semantics/#ingredient-used-by-multiple-interactions","text":"Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by 1 transition we have to add a layer to duplicate the token for all transitions.","title":"Ingredient used by multiple interactions"},{"location":"documentation/execution-semantics/#interaction-with-precondition-and","text":"By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction.","title":"Interaction with precondition (AND)"},{"location":"documentation/execution-semantics/#interaction-with-precodition-or","text":"Events that are grouped in an OR combinator for an interaction output a token to the same place. Therefor when one of them fires the condition for the transition to fire is met.","title":"Interaction with precodition (OR)"},{"location":"documentation/execution-semantics/#sensory-event-with-firing-limit","text":"When specifying a sensory event with a firing limit of n we generate a in-adjacent place with n tokens in the initial marking.","title":"Sensory event with firing limit"},{"location":"documentation/interactions/","text":"Interactions Defining You define an interaction with a java interface. An example: package com.example ; import com.ing.baker.recipe.annotations.* ; import javax.inject.Named ; public interface ValidateOrder { interface Outcome { } class Failed extends Outcome { } class Valid extends Outcome { } @FiresEvent ( oneOf = { Failed . class , Valid . class }) Outcome apply ( @ProcessId String processId , @Named ( order ) String key ); } To be used as an interaction the interface requires an apply method with some restrictions. The method must be annotated with `@FiresEvent ALL arguments must be annotated: @Named or @RequiresIngredient are used for ingredient data that the interaction requires, the name must be specfied. @ProcessId is used for injecting the process id . The output classes have the same restrictions as sensory events. Implementation Implementation is just implementing the interface. Nothing to explain here.","title":"Interactions"},{"location":"documentation/interactions/#interactions","text":"","title":"Interactions"},{"location":"documentation/interactions/#defining","text":"You define an interaction with a java interface. An example: package com.example ; import com.ing.baker.recipe.annotations.* ; import javax.inject.Named ; public interface ValidateOrder { interface Outcome { } class Failed extends Outcome { } class Valid extends Outcome { } @FiresEvent ( oneOf = { Failed . class , Valid . class }) Outcome apply ( @ProcessId String processId , @Named ( order ) String key ); } To be used as an interaction the interface requires an apply method with some restrictions. The method must be annotated with `@FiresEvent ALL arguments must be annotated: @Named or @RequiresIngredient are used for ingredient data that the interaction requires, the name must be specfied. @ProcessId is used for injecting the process id . The output classes have the same restrictions as sensory events.","title":"Defining"},{"location":"documentation/interactions/#implementation","text":"Implementation is just implementing the interface. Nothing to explain here.","title":"Implementation"},{"location":"documentation/process-execution/","text":"Process Execution Recap On the runtime page we discussed how you could could initialize Baker and add your recipe to it. Lets summarize what we have done so far. Scala // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe val baker : Baker = ??? // The recipe id was given to us when we add our Recipe to Baker val recipeId : String = ??? Java // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe JBaker baker = null ; // // The recipe id was given to us when we add our Recipe to Baker String recipeId = ... ; Create a process instance Given a valid recipe id we can now execute a Recipe. Or in other words we can create a process instance . Scala // Assuming you have a compiled recipe val recipe : CompiledRecipe = ??? // A unique identifier ment to distinguish this process from other process instances val processId = a-unique-process-id // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId , processId ) Java // Assuming you have a compiled recipe CompiledRecipe recipe = null ; // // A unique identifier ment to distinguish this process from other process instances String processId = a-unique-process-id ; // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId (), processId ); Providing a sensory event In our webshop example the first events that can happen are OrderPlaced , PaymentMade and CustomerInfoReceived . These are so called sensory events since they are not the result of an interaction but must be provided by the user of Baker. Scala // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) val customerInfo = CustomerInfo ( John , Elm. Street , johndoe@example.com ) val order = 123 ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( processId , CustomerInfoRecived ( customerInfo )) baker . processEvent ( processId , OrderPlaced ( order )) Java // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) CustomerInfo customerInfo = new CustomerInfo ( John , Elm. Street , johndoe@example.com ); String order = 123 ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( processId , new CustomerInfoReceived ( customerInfo )); baker . processEvent ( processId , new OrderPlaced ( order )); When receiving events Baker will check which Interactions have all the required Ingredients and Events met. It will execute those interactions. Those interactions will raise more events. For more information about the exact execution sementics see here . Correlation id Optionally you may provide a correlation id with an event. The purpose of this identifier is idempotent event delivery. When sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val orderId = a unique order id val statusA : SensoryEventStatus = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ) val statusB : SensoryEventStatus = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ) // statusA == Received // statusB == AlreadyReceived Java String orderId = a unique order id ; SensoryEventStatus statusA = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ); SensoryEventStatus statusB = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ); // statusA == Received // statusB == AlreadyReceived Sensory event status In response to recieving a sensory event baker returns a status code indicating how it processed it. Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met State inquiry During runtime it is often useful to inquire on the state of a process instance. Visualize process instance state We can use the visualizer to see what Baker has done with the given events. Scala val dotRepresentation : String = baker . getVisualState ( processId ) Java String dotRepresentation = baker . getVisualState ( processId ); Did you know?! You can ask baker for a visual representation of a certain process. That way you can see which Events where provided and which Interaction are ran. See the visualization page how to create a visual graph. The image shows us that the ValidateOrder Interaction is colored green which means that the Interaction has been exucuted. Baker was able to exeucte the Interaction because all required Events and Ingredients where provided. The ValidateOrder Interaction in turn produced the Valid event. We can also see that the ManufactureGoods Interaction is still purple, meaning that it has not been executed. This is correct because ManufactureGoods requires an additional event called PaymentMade . Events We can ask Baker for a list of all the events for our process. Using this list we can check if the InvoiceWasSend event was produced. Scala // Get all events that have happend for this process instance val events : Seq [ RuntimeEvent ] = baker . getEvents ( processId ) if ( events . exists ( _ . name == InvoiceWasSend )) // Yes the invoice was send! Java // Get all events that have happend for this process instance EventList events = baker . getEvents ( processId ); if ( events . hasEventOccured ( InvoiceWasSend . class )) // Yes the invoice was send! Ingredients Sometimes it is useful to know what the ingredient values are accumulated for a process instance. For example, you might want to know the value of the trackingId . Scala // Get all ingredients that are accumulated for a process instance val ingredients : Map [ String , Value ] = baker . getIngredients ( processId ) val trackingId : String = ingredients ( trackingId ). as [ String ] Java // Get all ingredients that are accumulated for a process instance Map String , Value ingredients = baker . getIngredients ( processId ); String trackingId = ingredients . get ( trackingId ). as ( String . class );","title":"Process Execution"},{"location":"documentation/process-execution/#process-execution","text":"","title":"Process Execution"},{"location":"documentation/process-execution/#recap","text":"On the runtime page we discussed how you could could initialize Baker and add your recipe to it. Lets summarize what we have done so far. Scala // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe val baker : Baker = ??? // The recipe id was given to us when we add our Recipe to Baker val recipeId : String = ??? Java // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe JBaker baker = null ; // // The recipe id was given to us when we add our Recipe to Baker String recipeId = ... ;","title":"Recap"},{"location":"documentation/process-execution/#create-a-process-instance","text":"Given a valid recipe id we can now execute a Recipe. Or in other words we can create a process instance . Scala // Assuming you have a compiled recipe val recipe : CompiledRecipe = ??? // A unique identifier ment to distinguish this process from other process instances val processId = a-unique-process-id // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId , processId ) Java // Assuming you have a compiled recipe CompiledRecipe recipe = null ; // // A unique identifier ment to distinguish this process from other process instances String processId = a-unique-process-id ; // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId (), processId );","title":"Create a process instance"},{"location":"documentation/process-execution/#providing-a-sensory-event","text":"In our webshop example the first events that can happen are OrderPlaced , PaymentMade and CustomerInfoReceived . These are so called sensory events since they are not the result of an interaction but must be provided by the user of Baker. Scala // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) val customerInfo = CustomerInfo ( John , Elm. Street , johndoe@example.com ) val order = 123 ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( processId , CustomerInfoRecived ( customerInfo )) baker . processEvent ( processId , OrderPlaced ( order )) Java // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) CustomerInfo customerInfo = new CustomerInfo ( John , Elm. Street , johndoe@example.com ); String order = 123 ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( processId , new CustomerInfoReceived ( customerInfo )); baker . processEvent ( processId , new OrderPlaced ( order )); When receiving events Baker will check which Interactions have all the required Ingredients and Events met. It will execute those interactions. Those interactions will raise more events. For more information about the exact execution sementics see here .","title":"Providing a sensory event"},{"location":"documentation/process-execution/#correlation-id","text":"Optionally you may provide a correlation id with an event. The purpose of this identifier is idempotent event delivery. When sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val orderId = a unique order id val statusA : SensoryEventStatus = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ) val statusB : SensoryEventStatus = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ) // statusA == Received // statusB == AlreadyReceived Java String orderId = a unique order id ; SensoryEventStatus statusA = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ); SensoryEventStatus statusB = baker . processEvent ( processId , new OrderPlaced ( order ), orderId ); // statusA == Received // statusB == AlreadyReceived","title":"Correlation id"},{"location":"documentation/process-execution/#sensory-event-status","text":"In response to recieving a sensory event baker returns a status code indicating how it processed it. Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met","title":"Sensory event status"},{"location":"documentation/process-execution/#state-inquiry","text":"During runtime it is often useful to inquire on the state of a process instance.","title":"State inquiry"},{"location":"documentation/process-execution/#visualize-process-instance-state","text":"We can use the visualizer to see what Baker has done with the given events. Scala val dotRepresentation : String = baker . getVisualState ( processId ) Java String dotRepresentation = baker . getVisualState ( processId ); Did you know?! You can ask baker for a visual representation of a certain process. That way you can see which Events where provided and which Interaction are ran. See the visualization page how to create a visual graph. The image shows us that the ValidateOrder Interaction is colored green which means that the Interaction has been exucuted. Baker was able to exeucte the Interaction because all required Events and Ingredients where provided. The ValidateOrder Interaction in turn produced the Valid event. We can also see that the ManufactureGoods Interaction is still purple, meaning that it has not been executed. This is correct because ManufactureGoods requires an additional event called PaymentMade .","title":"Visualize process instance state"},{"location":"documentation/process-execution/#events","text":"We can ask Baker for a list of all the events for our process. Using this list we can check if the InvoiceWasSend event was produced. Scala // Get all events that have happend for this process instance val events : Seq [ RuntimeEvent ] = baker . getEvents ( processId ) if ( events . exists ( _ . name == InvoiceWasSend )) // Yes the invoice was send! Java // Get all events that have happend for this process instance EventList events = baker . getEvents ( processId ); if ( events . hasEventOccured ( InvoiceWasSend . class )) // Yes the invoice was send!","title":"Events"},{"location":"documentation/process-execution/#ingredients","text":"Sometimes it is useful to know what the ingredient values are accumulated for a process instance. For example, you might want to know the value of the trackingId . Scala // Get all ingredients that are accumulated for a process instance val ingredients : Map [ String , Value ] = baker . getIngredients ( processId ) val trackingId : String = ingredients ( trackingId ). as [ String ] Java // Get all ingredients that are accumulated for a process instance Map String , Value ingredients = baker . getIngredients ( processId ); String trackingId = ingredients . get ( trackingId ). as ( String . class );","title":"Ingredients"},{"location":"documentation/recipe-dsl/","text":"Recipe DSL The recipe DSL allows you to declaritively describe your process. Let's start with the web shop recipe as an example. The complete code example can be found here . final Recipe webshopRecipe = new Recipe ( webshop ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class , PaymentMade . class ) . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class ) . withRequiredEvents ( PaymentMade . class , ValidateOrder . Valid . class ), of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ), of ( ShipGoods . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ()); Sensory events Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the baker type system. See the supported types for more information. The names of the fields are obtained using java reflection. They can be added using the .withSensoryEvents(..) method. Firing limit A firing limit is a limit on the number of times a sensory event may be received by a process instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance. Interactions Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( webshop ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe. Maximum interaction count By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) ) Predefining ingredients An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( emailTemplate , Welcome to ING! ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction. Event requirements As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured. Interaction Failure strategy When an interaction throws an exception there are a number of mitigation strategies: Fire event This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( ValidateOrderFailed ) ) ) Retry with incremental backoff Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis - 200 millis - 400 millis - ... - 100 seconds - 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number.","title":"Recipe DSL"},{"location":"documentation/recipe-dsl/#recipe-dsl","text":"The recipe DSL allows you to declaritively describe your process. Let's start with the web shop recipe as an example. The complete code example can be found here . final Recipe webshopRecipe = new Recipe ( webshop ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class , PaymentMade . class ) . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class ) . withRequiredEvents ( PaymentMade . class , ValidateOrder . Valid . class ), of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ), of ( ShipGoods . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Recipe DSL"},{"location":"documentation/recipe-dsl/#sensory-events","text":"Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the baker type system. See the supported types for more information. The names of the fields are obtained using java reflection. They can be added using the .withSensoryEvents(..) method.","title":"Sensory events"},{"location":"documentation/recipe-dsl/#firing-limit","text":"A firing limit is a limit on the number of times a sensory event may be received by a process instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance.","title":"Firing limit"},{"location":"documentation/recipe-dsl/#interactions","text":"Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( webshop ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe.","title":"Interactions"},{"location":"documentation/recipe-dsl/#maximum-interaction-count","text":"By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) )","title":"Maximum interaction count"},{"location":"documentation/recipe-dsl/#predefining-ingredients","text":"An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( emailTemplate , Welcome to ING! ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction.","title":"Predefining ingredients"},{"location":"documentation/recipe-dsl/#event-requirements","text":"As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured.","title":"Event requirements"},{"location":"documentation/recipe-dsl/#interaction-failure-strategy","text":"When an interaction throws an exception there are a number of mitigation strategies:","title":"Interaction Failure strategy"},{"location":"documentation/recipe-dsl/#fire-event","text":"This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( ValidateOrderFailed ) ) )","title":"Fire event"},{"location":"documentation/recipe-dsl/#retry-with-incremental-backoff","text":"Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis - 200 millis - 400 millis - ... - 100 seconds - 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number.","title":"Retry with incremental backoff"},{"location":"documentation/recipe-visualization/","text":"Recipe Visualization Here we explain how to create a visual representation of your recipe like this one Generate a .dot representation Baker can turn a recipe into a .dot representation. .dot is a notation for representing graphs. Scala val recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ) println ( recipe . getRecipeVisualization ) Java final CompiledRecipe recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ); System . out . println ( recipe . getRecipeVisualization ()); This should output something like this: digraph d { A [label= Hello ] B [label= World ] C [label= Everyone ] A - { B C } } Visualize Once you have a .dot representation there are a few methods to visualize this. Online You can copy the .dot string and use webgraphviz.com . Local To generate an image locally you require the graphviz tool. See graphviz.org on how to install it. On mac you can use brew . brew install graphviz Once installed the dot command can be used to create an SVG by running: dot -v -Tsvg -O graph.dot In application Alternatively you can use graphviz-java to generate the SVG in your code: Scala import guru.nidi.graphviz.engine. { Format , Graphviz } import guru.nidi.graphviz.parse.Parser val graph = Parser . read ( recipe . getRecipeVisualization ) Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString Java import guru.nidi.graphviz.engine.Format ; import guru.nidi.graphviz.engine.Graphviz ; import guru.nidi.graphviz.parse.Parser ; import guru.nidi.graphviz.model.MutableGraph ; MutableGraph graph = Parser . read ( recipe . getRecipeVisualization ); Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString ; Style customization It is possible to define a custom visual style for your recipes. To do so you need to add some configuration in your application.conf : baker.visualization { style = custom styles.custom = { // place your style attributes here } } Please see the default theme in the reference.conf as an example. For an overview on what is possible to configure check out the graphviz documentation. It is not possible to alter the shape attribute, it is hard coded (fixed) for all elements in the graph. This is done to garuantee a common visual language for all recipes.","title":"Recipe Visualization"},{"location":"documentation/recipe-visualization/#recipe-visualization","text":"Here we explain how to create a visual representation of your recipe like this one","title":"Recipe Visualization"},{"location":"documentation/recipe-visualization/#generate-a-dot-representation","text":"Baker can turn a recipe into a .dot representation. .dot is a notation for representing graphs. Scala val recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ) println ( recipe . getRecipeVisualization ) Java final CompiledRecipe recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ); System . out . println ( recipe . getRecipeVisualization ()); This should output something like this: digraph d { A [label= Hello ] B [label= World ] C [label= Everyone ] A - { B C } }","title":"Generate a .dot representation"},{"location":"documentation/recipe-visualization/#visualize","text":"Once you have a .dot representation there are a few methods to visualize this.","title":"Visualize"},{"location":"documentation/recipe-visualization/#online","text":"You can copy the .dot string and use webgraphviz.com .","title":"Online"},{"location":"documentation/recipe-visualization/#local","text":"To generate an image locally you require the graphviz tool. See graphviz.org on how to install it. On mac you can use brew . brew install graphviz Once installed the dot command can be used to create an SVG by running: dot -v -Tsvg -O graph.dot","title":"Local"},{"location":"documentation/recipe-visualization/#in-application","text":"Alternatively you can use graphviz-java to generate the SVG in your code: Scala import guru.nidi.graphviz.engine. { Format , Graphviz } import guru.nidi.graphviz.parse.Parser val graph = Parser . read ( recipe . getRecipeVisualization ) Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString Java import guru.nidi.graphviz.engine.Format ; import guru.nidi.graphviz.engine.Graphviz ; import guru.nidi.graphviz.parse.Parser ; import guru.nidi.graphviz.model.MutableGraph ; MutableGraph graph = Parser . read ( recipe . getRecipeVisualization ); Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString ;","title":"In application"},{"location":"documentation/recipe-visualization/#style-customization","text":"It is possible to define a custom visual style for your recipes. To do so you need to add some configuration in your application.conf : baker.visualization { style = custom styles.custom = { // place your style attributes here } } Please see the default theme in the reference.conf as an example. For an overview on what is possible to configure check out the graphviz documentation. It is not possible to alter the shape attribute, it is hard coded (fixed) for all elements in the graph. This is done to garuantee a common visual language for all recipes.","title":"Style customization"},{"location":"documentation/split-brain-resolver/","text":"Split Brain Resolver Description Note: This feature is applicable to clustered baker configuration. If your Baker application is using local actors, thus not using akka cluster, a Split Brain Resolver is not needed. Baker library, when configured to be a cluster, runs in an akka cluster to distribute the baker processes over multiple nodes. Running a cluster with multiple nodes with shared state has some difficulties to tackle in some network failure scenarios, like network partitions. When there's a network partition in a cluster, the nodes at the different sides of the partition cannot receive messages from each other and eventually diverge their states unless it is a network hick-up. When this happens, you need a mechanism to prevent state inconsistency, i.e. by stopping nodes at one side of the partition, so the nodes at the surviving side still run with consistent states. A Split Brain Resolver algorithm for Akka prevents inconsistent states during network partitions, or huge network delays, or non-responding cluster members. Baker Split Brain Resolver is a general purpose implementation for Akka which could be configured for a baker cluster as well as for another akka cluster without baker. Strategies The current version of the Split Brain Resolver algorithm supports only the Majority strategy which makes the majority of the nodes survive and downs (terminates) the nodes at the minority side of the network partition. In case of the number of nodes on each side of the network partition are equal, the side with the oldest akka node survives. By deciding to down one side, you do not end up with 2 akka clusters during the network partition. There could be other strategies implemented later, for now the Majority strategy works for most of the use cases. You can read about other possible strategies supported by the commercial Lightbend Split Brain Resolver here . Majority strategy is configured by default, so you do not need extra configuration for this. How to use In order to use Baker SplitBrainResolver , first of all, you need to add baker-split-brain-resolver dependency to your project. See example below: Sbt libraryDependencies += com.ing.baker %% baker-split-brain-resolver % 2.0.2 Maven dependency groupId com.ing.baker /groupId artifactId baker-split-brain-resolver_2.12 /artifactId version 2.0.2 /version /dependency Then the algorithm needs to be configured as the akka downing provider and the stable-after config needs to set to some duration depending on your cluster size. stable-after config is needed to decide on how quickly to react on the akka cluster state changes. Very short durations may allow quicker 'downing' decisions for unreachable nodes, but may also cause to down some nodes unnecessarily too early. Please see the suggested values for this in the documentation of the commercial Lightbend Split Brain Resolver. One other akka cluster configuration suggested keep in sync with stable-after is the akka.cluster.down-removal-margin config. The suggested values and more information on this config can be found in the Cluster Singleton and Cluster Sharding section of the commercial Lightbend Split Brain Resolver. Example config for a baker cluster having less than 10 nodes is the following: akka.cluster.down-removal-margin = 7 seconds akka.cluster.downing-provider-class = com.ing.baker.runtime.actor.downing.SplitBrainResolver baker-split-brain-resolver { stable-after = 7 seconds }","title":"Split Brain Resolver"},{"location":"documentation/split-brain-resolver/#split-brain-resolver","text":"","title":"Split Brain Resolver"},{"location":"documentation/split-brain-resolver/#description","text":"Note: This feature is applicable to clustered baker configuration. If your Baker application is using local actors, thus not using akka cluster, a Split Brain Resolver is not needed. Baker library, when configured to be a cluster, runs in an akka cluster to distribute the baker processes over multiple nodes. Running a cluster with multiple nodes with shared state has some difficulties to tackle in some network failure scenarios, like network partitions. When there's a network partition in a cluster, the nodes at the different sides of the partition cannot receive messages from each other and eventually diverge their states unless it is a network hick-up. When this happens, you need a mechanism to prevent state inconsistency, i.e. by stopping nodes at one side of the partition, so the nodes at the surviving side still run with consistent states. A Split Brain Resolver algorithm for Akka prevents inconsistent states during network partitions, or huge network delays, or non-responding cluster members. Baker Split Brain Resolver is a general purpose implementation for Akka which could be configured for a baker cluster as well as for another akka cluster without baker.","title":"Description"},{"location":"documentation/split-brain-resolver/#strategies","text":"The current version of the Split Brain Resolver algorithm supports only the Majority strategy which makes the majority of the nodes survive and downs (terminates) the nodes at the minority side of the network partition. In case of the number of nodes on each side of the network partition are equal, the side with the oldest akka node survives. By deciding to down one side, you do not end up with 2 akka clusters during the network partition. There could be other strategies implemented later, for now the Majority strategy works for most of the use cases. You can read about other possible strategies supported by the commercial Lightbend Split Brain Resolver here . Majority strategy is configured by default, so you do not need extra configuration for this.","title":"Strategies"},{"location":"documentation/split-brain-resolver/#how-to-use","text":"In order to use Baker SplitBrainResolver , first of all, you need to add baker-split-brain-resolver dependency to your project. See example below: Sbt libraryDependencies += com.ing.baker %% baker-split-brain-resolver % 2.0.2 Maven dependency groupId com.ing.baker /groupId artifactId baker-split-brain-resolver_2.12 /artifactId version 2.0.2 /version /dependency Then the algorithm needs to be configured as the akka downing provider and the stable-after config needs to set to some duration depending on your cluster size. stable-after config is needed to decide on how quickly to react on the akka cluster state changes. Very short durations may allow quicker 'downing' decisions for unreachable nodes, but may also cause to down some nodes unnecessarily too early. Please see the suggested values for this in the documentation of the commercial Lightbend Split Brain Resolver. One other akka cluster configuration suggested keep in sync with stable-after is the akka.cluster.down-removal-margin config. The suggested values and more information on this config can be found in the Cluster Singleton and Cluster Sharding section of the commercial Lightbend Split Brain Resolver. Example config for a baker cluster having less than 10 nodes is the following: akka.cluster.down-removal-margin = 7 seconds akka.cluster.downing-provider-class = com.ing.baker.runtime.actor.downing.SplitBrainResolver baker-split-brain-resolver { stable-after = 7 seconds }","title":"How to use"},{"location":"documentation/type-system/","text":"Type system The purpose of the type system is express the form of ingredients in baker. Why not use the java type system? To garuantee that all data can be read back from persistent storage. This is for the benefit of being able to write generic analysis/data-mining tools on the persisted events. To run Baker As A Service, receiving new recipes at runtime. Unless opting for OSGi or similar, you cannot load new class definitions. This makes it very impractical or impossible to depend on java classes. The main concepts in this type system are Types and Values . An important difference from type systems in programming languages is that Values do not have an explicit inherint type associated with them. You can argue whether you can call this a type system at all. Perhaps a schema system is more accurate. Types Primitives Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array Byte Byte array, often used for binary data CharArray String Character array, or commmonly called String Structured types Type Java parallel Description ListType T java.util.List T A list of values, all of the same type OptionType T java.util.Optional T Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType T java.util.Map String, T A record with arbitrary fields, all of the same type Values Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array Byte ListValue A list of values RecordValue A set of String - Value pairs Interoptability with java types Because it is impractical to directly work with the baker types in java/scala code there is conversion system. Default supported types java primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes scala primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option Registering a custom type adapter All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { com.example.MyCustomType = com.example.MyCustomTypeAdpater } For an example how to implement an adapter see here","title":"Type system"},{"location":"documentation/type-system/#type-system","text":"The purpose of the type system is express the form of ingredients in baker.","title":"Type system"},{"location":"documentation/type-system/#why-not-use-the-java-type-system","text":"To garuantee that all data can be read back from persistent storage. This is for the benefit of being able to write generic analysis/data-mining tools on the persisted events. To run Baker As A Service, receiving new recipes at runtime. Unless opting for OSGi or similar, you cannot load new class definitions. This makes it very impractical or impossible to depend on java classes. The main concepts in this type system are Types and Values . An important difference from type systems in programming languages is that Values do not have an explicit inherint type associated with them. You can argue whether you can call this a type system at all. Perhaps a schema system is more accurate.","title":"Why not use the java type system?"},{"location":"documentation/type-system/#types","text":"","title":"Types"},{"location":"documentation/type-system/#primitives","text":"Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array Byte Byte array, often used for binary data CharArray String Character array, or commmonly called String","title":"Primitives"},{"location":"documentation/type-system/#structured-types","text":"Type Java parallel Description ListType T java.util.List T A list of values, all of the same type OptionType T java.util.Optional T Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType T java.util.Map String, T A record with arbitrary fields, all of the same type","title":"Structured types"},{"location":"documentation/type-system/#values","text":"Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array Byte ListValue A list of values RecordValue A set of String - Value pairs","title":"Values"},{"location":"documentation/type-system/#interoptability-with-java-types","text":"Because it is impractical to directly work with the baker types in java/scala code there is conversion system.","title":"Interoptability with java types"},{"location":"documentation/type-system/#default-supported-types","text":"","title":"Default supported types"},{"location":"documentation/type-system/#java","text":"primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes","title":"java"},{"location":"documentation/type-system/#scala","text":"primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option","title":"scala"},{"location":"documentation/type-system/#registering-a-custom-type-adapter","text":"All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { com.example.MyCustomType = com.example.MyCustomTypeAdpater } For an example how to implement an adapter see here","title":"Registering a custom type adapter"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/","text":"Declare, verify and execute microservices-based process flows with Baker Scale By the Bay 2017, San Francisco Nikola Kasev | ING Bank Global Financial Institution in Over 40 Countries Software Company with a Banking License Microservices Architecture Our Challenge Interact with 12 Different Systems A Flow of 27 Steps From 2 minutes to 6 hours Afraid to Change the Application Code Functionality Breaks Unexpectedly Slow Time to Market How to Turn This Around? Simplify Domain Specific Language for Orchestration Flows Declarative Easy to Change Recipes Interactions Ingredients Events Communicate Visualize your code Non-IT understand as well Reason About Comfortably Let's Cook Some Cr\u00eapes! Good to Know Short-lived vs. long-running flows State is taken care of: Cassandra for persistent storage Ingredients encrypted by default State recovered automatically When failure occurs: Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Ownerhip Register Ownership n/a https://github.com/ing-bank/baker Why Petri net? ^3 Design-time val registerIndividual = Interaction ( name = RegisterIndividual , inputIngredients = Seq ( name , address ), output = Seq ( registerIndividualSuccessful , registerIndividualFailed ) ) val recipe = Recipe ( OpenAccountRecipe ) . withInteractions ( assignAccount , getAccount , registerIndividual ) val recipe = Recipe ( OpenAccountRecipe ) . withInteractions ( assignAccount , getAccount . withRequiredEvent ( termsAndConditionsAccepted ), registerIndividual ) . withSensoryEvents ( termsAndConditionsAccepted , individualInformationSubmitted ) Run-time //for each process instance, bake the recipe baker . bake ( processId ); //notify Baker when events occur baker . processEvent ( processId , individualInformationSubmitted . instance ( name , address )); baker . processEvent ( processId , termsAndConditionsAccepted . instance ()); //retrieve ingredients stored in the accumulated state assert ( baker . getIngredients ( processId ). get ( customerId ). equals ( customerId )); assert ( baker . getIngredients ( processId ). get ( iban ). equals ( iban )); //retrieve all events that have occurred baker . events ( processId ) val groceriesDone = new Event(\"GroceriesDone\", Seq(milk, eggs, flour, butter, creme), Some(1)) val mixFirstThree = Interaction( name = \"MixFirstThree\", inputIngredients = Seq(milk, eggs, flour), output = Seq(batterMixed) ) val mixFirstThreeImpl = mixFirstThree implement { (milk: String, eggs: String, flour: String) = println(s\"mixing $milk, $eggs, and $flour\") batterMixed.instance(\"batter\") } I love cooking food and for the rest of the talk I'll be using examples from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#declare-verify-and-execute-microservices-based-process-flows-with-baker","text":"","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#scale-by-the-bay-2017-san-francisco","text":"","title":"Scale By the Bay 2017, San Francisco"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#nikola-kasev-ing-bank","text":"","title":"Nikola Kasev | ING Bank"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#global-financial-institution-in-over-40-countries","text":"","title":"Global Financial Institution in Over 40 Countries"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#software-company-with-a-banking-license","text":"","title":"Software Company with a Banking License"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#microservices-architecture","text":"","title":"Microservices Architecture"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#our-challenge","text":"","title":"Our Challenge"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#interact-with-12-different-systems","text":"","title":"Interact with 12 Different Systems"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#a-flow-of-27-steps","text":"","title":"A Flow of 27 Steps"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#from-2-minutes-to-6-hours","text":"","title":"From 2 minutes to 6 hours"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#afraid-to-change-the-application-code","text":"","title":"Afraid to Change the Application Code"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#functionality-breaks-unexpectedly","text":"","title":"Functionality Breaks Unexpectedly"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#slow-time-to-market","text":"","title":"Slow Time to Market"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#how-to-turn-this-around","text":"","title":"How to Turn This Around?"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#simplify","text":"","title":"Simplify"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#domain-specific-language-for-orchestration-flows","text":"","title":"Domain Specific Language for Orchestration Flows"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#declarative","text":"","title":"Declarative"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#easy-to-change","text":"","title":"Easy to Change"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#recipes","text":"","title":"Recipes"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#interactions","text":"","title":"Interactions"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#ingredients","text":"","title":"Ingredients"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#events","text":"","title":"Events"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#communicate","text":"","title":"Communicate"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#visualize-your-code","text":"","title":"Visualize your code"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#non-it-understand-as-well","text":"","title":"Non-IT understand as well"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#reason-about-comfortably","text":"","title":"Reason About Comfortably"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#lets-cook-some-crepes","text":"","title":"Let's Cook Some Cr\u00eapes!"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#good-to-know","text":"","title":"Good to Know"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#short-lived-vs-long-running-flows","text":"","title":"Short-lived vs. long-running flows"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#state-is-taken-care-of","text":"Cassandra for persistent storage Ingredients encrypted by default State recovered automatically","title":"State is taken care of:"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#when-failure-occurs","text":"Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Ownerhip Register Ownership n/a","title":"When failure occurs:"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#httpsgithubcoming-bankbaker","text":"","title":"https://github.com/ing-bank/baker"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#why-petri-net3","text":"","title":"Why Petri net?^3"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#design-time","text":"val registerIndividual = Interaction ( name = RegisterIndividual , inputIngredients = Seq ( name , address ), output = Seq ( registerIndividualSuccessful , registerIndividualFailed ) ) val recipe = Recipe ( OpenAccountRecipe ) . withInteractions ( assignAccount , getAccount , registerIndividual ) val recipe = Recipe ( OpenAccountRecipe ) . withInteractions ( assignAccount , getAccount . withRequiredEvent ( termsAndConditionsAccepted ), registerIndividual ) . withSensoryEvents ( termsAndConditionsAccepted , individualInformationSubmitted )","title":"Design-time"},{"location":"presentations/ScaleByTheBay-18-Nov-2017/#run-time","text":"//for each process instance, bake the recipe baker . bake ( processId ); //notify Baker when events occur baker . processEvent ( processId , individualInformationSubmitted . instance ( name , address )); baker . processEvent ( processId , termsAndConditionsAccepted . instance ()); //retrieve ingredients stored in the accumulated state assert ( baker . getIngredients ( processId ). get ( customerId ). equals ( customerId )); assert ( baker . getIngredients ( processId ). get ( iban ). equals ( iban )); //retrieve all events that have occurred baker . events ( processId ) val groceriesDone = new Event(\"GroceriesDone\", Seq(milk, eggs, flour, butter, creme), Some(1)) val mixFirstThree = Interaction( name = \"MixFirstThree\", inputIngredients = Seq(milk, eggs, flour), output = Seq(batterMixed) ) val mixFirstThreeImpl = mixFirstThree implement { (milk: String, eggs: String, flour: String) = println(s\"mixing $milk, $eggs, and $flour\") batterMixed.instance(\"batter\") } I love cooking food and for the rest of the talk I'll be using examples from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Run-time"},{"location":"presentations/baker-pitch/","text":"[fit] Orchestration Logic is Hard to Change Baker is a Java Library Declare the Logic Like a Recipe Visualize the Logic Don't Worry About Retries and State Rapid Time to Market Less Incidents Business and IT Speak the Same Language Under the Hood DSL for Recipes Actor Model with Petri nets Event-Driven Architecture ```java, [.highlight: 3,4,6] return new Recipe(\"DemoAtTwitterHQ\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } --- ```java //notify Baker when events occur baker.processEvent(processId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(processId, new SensoryEvents.TermsAndConditionsAccepted());","title":"[fit] Orchestration Logic is Hard to Change"},{"location":"presentations/baker-pitch/#fit-orchestration-logic-is-hard-to-change","text":"","title":"[fit] Orchestration Logic is Hard to Change"},{"location":"presentations/baker-pitch/#baker-is-a-java-library","text":"","title":"Baker is a Java Library"},{"location":"presentations/baker-pitch/#declare-the-logic-like-a-recipe","text":"","title":"Declare the Logic Like a Recipe"},{"location":"presentations/baker-pitch/#visualize-the-logic","text":"","title":"Visualize the Logic"},{"location":"presentations/baker-pitch/#dont-worry-about-retries-and-state","text":"","title":"Don't Worry About Retries and State"},{"location":"presentations/baker-pitch/#rapid-time-to-market","text":"","title":"Rapid Time to Market"},{"location":"presentations/baker-pitch/#less-incidents","text":"","title":"Less Incidents"},{"location":"presentations/baker-pitch/#business-and-it-speak-the-same-language","text":"","title":"Business and IT Speak the Same Language"},{"location":"presentations/baker-pitch/#under-the-hood","text":"","title":"Under the Hood"},{"location":"presentations/baker-pitch/#dsl-for-recipes","text":"","title":"DSL for Recipes"},{"location":"presentations/baker-pitch/#actor-model-with-petri-nets","text":"","title":"Actor Model with Petri nets"},{"location":"presentations/baker-pitch/#event-driven-architecture","text":"```java, [.highlight: 3,4,6] return new Recipe(\"DemoAtTwitterHQ\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } --- ```java //notify Baker when events occur baker.processEvent(processId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(processId, new SensoryEvents.TermsAndConditionsAccepted());","title":"Event-Driven Architecture"},{"location":"presentations/muCon-London-7-Nov-2017/","text":"Declare, verify and execute microservices-based process flows with Baker http://github.com/nikolakasev | ING Symptoms of a Failing Restaurant Symptoms of a Failing (Microservices) Architecture Afraid to change the application code Functionality breaks unexpectedly Slow time to market How to turn this around? Simplify Domain Specific Language for orchestration flows Declarative Easy to change Reuse Recipes Interactions Ingredients Events Communicate Visualize your code Non-IT understand as well Reason About Comfortably Design-time ```[.highlight: 1,6,7] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @ProcessId String processId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } --- ```[.highlight: 2,3] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @ProcessId String processId, @RequiresIngredient( name ) String name, @RequiresIngredient( address ) String address ); } ```java, [.highlight: 3-6] public Recipe get(){ return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class), of(RegisterIndividual.class)); } --- ![fit](recipe-no-sensory.png) --- ```java, [.highlight: 5, 7-9] return new Recipe( MuConf2017Demo ). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } Run-time ```java, [.highlight: 2,4,5,8,9,13] //for each process instance, bake the recipe baker.bake(processId); //notify Baker when events occur baker.processEvent(processId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(processId, new SensoryEvents.TermsAndConditionsAccepted()); //retrieve ingredients stored in the accumulated state assert(baker.getIngredients(processId).get(\"customerId\").equals(customerId)); assert(baker.getIngredients(processId).get(\"iban\").equals(iban)); //retrieve all events that have occurred Set occurredEvents = new HashSet ( baker.getEvents(processId).getEventNameList() ); ``` Under the Hood Why Scala? Best fit for developing DSLs ^1 on the JVM Compile-time recipe validation Type safety Why Akka? Event Sourcing ^2 (events can be replayed) Persistent actors (with Cassandra) Distributed actors across machines (with cluster sharding) Why Petri net? ^3 Best Practices Short-lived vs. long-running flows State is taken care of: Cassandra for persistent storage Ingredients encrypted by default State recovered automatically Run Baker inside of your API \"Smart endpoints and dumb pipes\" When failure occurs: Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Product Owner Register Product Owner n/a https://github.com/ing-bank/baker Speed of change matters to anyone building software. Many engineering teams have identified Microservices as an important component of this architectural approach to designing more flexible systems that can meet the needs of their fast changing businesses. Applying this approach however, is hard. And ideas and practices are still very much evolving. To help with that, we've launched muCon - a conference to learn about emerging technologies and approaches, share challenges and evolve practices and ideas. Their applications are built on top of microservices. If there careful enough their application serve bad meals. If we are building microservices or a monolith or any type of service in general we are serving business logic to our clients. So no matter what we can not escape the architectural discussion. If we are not careful of how we architect our applications we end up serving bad meals. I love cooking food and for the rest of the talk I'll be using analogies from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"presentations/muCon-London-7-Nov-2017/#declare-verify-and-execute-microservices-based-process-flows-with-baker","text":"","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"presentations/muCon-London-7-Nov-2017/#httpgithubcomnikolakasev-ing","text":"","title":"http://github.com/nikolakasev | ING"},{"location":"presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-restaurant","text":"","title":"Symptoms of a Failing Restaurant"},{"location":"presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-microservices-architecture","text":"","title":"Symptoms of a Failing (Microservices) Architecture"},{"location":"presentations/muCon-London-7-Nov-2017/#afraid-to-change-the-application-code","text":"","title":"Afraid to change the application code"},{"location":"presentations/muCon-London-7-Nov-2017/#functionality-breaks-unexpectedly","text":"","title":"Functionality breaks unexpectedly"},{"location":"presentations/muCon-London-7-Nov-2017/#slow-time-to-market","text":"","title":"Slow time to market"},{"location":"presentations/muCon-London-7-Nov-2017/#how-to-turn-this-around","text":"","title":"How to turn this around?"},{"location":"presentations/muCon-London-7-Nov-2017/#simplify","text":"","title":"Simplify"},{"location":"presentations/muCon-London-7-Nov-2017/#domain-specific-language-for-orchestration-flows","text":"","title":"Domain Specific Language for orchestration flows"},{"location":"presentations/muCon-London-7-Nov-2017/#declarative","text":"","title":"Declarative"},{"location":"presentations/muCon-London-7-Nov-2017/#easy-to-change","text":"","title":"Easy to change"},{"location":"presentations/muCon-London-7-Nov-2017/#reuse","text":"","title":"Reuse"},{"location":"presentations/muCon-London-7-Nov-2017/#recipes","text":"","title":"Recipes"},{"location":"presentations/muCon-London-7-Nov-2017/#interactions","text":"","title":"Interactions"},{"location":"presentations/muCon-London-7-Nov-2017/#ingredients","text":"","title":"Ingredients"},{"location":"presentations/muCon-London-7-Nov-2017/#events","text":"","title":"Events"},{"location":"presentations/muCon-London-7-Nov-2017/#communicate","text":"","title":"Communicate"},{"location":"presentations/muCon-London-7-Nov-2017/#visualize-your-code","text":"","title":"Visualize your code"},{"location":"presentations/muCon-London-7-Nov-2017/#non-it-understand-as-well","text":"","title":"Non-IT understand as well"},{"location":"presentations/muCon-London-7-Nov-2017/#reason-about-comfortably","text":"","title":"Reason About Comfortably"},{"location":"presentations/muCon-London-7-Nov-2017/#design-time","text":"```[.highlight: 1,6,7] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @ProcessId String processId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } --- ```[.highlight: 2,3] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @ProcessId String processId, @RequiresIngredient( name ) String name, @RequiresIngredient( address ) String address ); } ```java, [.highlight: 3-6] public Recipe get(){ return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class), of(RegisterIndividual.class)); } --- ![fit](recipe-no-sensory.png) --- ```java, [.highlight: 5, 7-9] return new Recipe( MuConf2017Demo ). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); }","title":"Design-time"},{"location":"presentations/muCon-London-7-Nov-2017/#run-time","text":"```java, [.highlight: 2,4,5,8,9,13] //for each process instance, bake the recipe baker.bake(processId); //notify Baker when events occur baker.processEvent(processId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(processId, new SensoryEvents.TermsAndConditionsAccepted()); //retrieve ingredients stored in the accumulated state assert(baker.getIngredients(processId).get(\"customerId\").equals(customerId)); assert(baker.getIngredients(processId).get(\"iban\").equals(iban)); //retrieve all events that have occurred Set occurredEvents = new HashSet ( baker.getEvents(processId).getEventNameList() ); ```","title":"Run-time"},{"location":"presentations/muCon-London-7-Nov-2017/#under-the-hood","text":"","title":"Under the Hood"},{"location":"presentations/muCon-London-7-Nov-2017/#why-scala","text":"Best fit for developing DSLs ^1 on the JVM Compile-time recipe validation Type safety","title":"Why Scala?"},{"location":"presentations/muCon-London-7-Nov-2017/#why-akka","text":"Event Sourcing ^2 (events can be replayed) Persistent actors (with Cassandra) Distributed actors across machines (with cluster sharding)","title":"Why Akka?"},{"location":"presentations/muCon-London-7-Nov-2017/#why-petri-net3","text":"","title":"Why Petri net?^3"},{"location":"presentations/muCon-London-7-Nov-2017/#best-practices","text":"","title":"Best Practices"},{"location":"presentations/muCon-London-7-Nov-2017/#short-lived-vs-long-running-flows","text":"","title":"Short-lived vs. long-running flows"},{"location":"presentations/muCon-London-7-Nov-2017/#state-is-taken-care-of","text":"Cassandra for persistent storage Ingredients encrypted by default State recovered automatically","title":"State is taken care of:"},{"location":"presentations/muCon-London-7-Nov-2017/#run-baker-inside-of-your-api","text":"","title":"Run Baker inside of your API"},{"location":"presentations/muCon-London-7-Nov-2017/#smart-endpoints-and-dumb-pipes","text":"","title":"\"Smart endpoints and dumb pipes\""},{"location":"presentations/muCon-London-7-Nov-2017/#when-failure-occurs","text":"Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Product Owner Register Product Owner n/a","title":"When failure occurs:"},{"location":"presentations/muCon-London-7-Nov-2017/#httpsgithubcoming-bankbaker","text":"Speed of change matters to anyone building software. Many engineering teams have identified Microservices as an important component of this architectural approach to designing more flexible systems that can meet the needs of their fast changing businesses. Applying this approach however, is hard. And ideas and practices are still very much evolving. To help with that, we've launched muCon - a conference to learn about emerging technologies and approaches, share challenges and evolve practices and ideas. Their applications are built on top of microservices. If there careful enough their application serve bad meals. If we are building microservices or a monolith or any type of service in general we are serving business logic to our clients. So no matter what we can not escape the architectural discussion. If we are not careful of how we architect our applications we end up serving bad meals. I love cooking food and for the rest of the talk I'll be using analogies from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"https://github.com/ing-bank/baker"}]}